<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Guto@Site</title>
    <link href="https://gutocarvalho.net/feed.xml" rel="self" />
    <link href="https://gutocarvalho.net" />
    <updated>2022-02-18T10:01:36-03:00</updated>
    <author>
        <name>Guto Carvalho</name>
    </author>
    <id>https://gutocarvalho.net</id>

    <entry>
        <title>Conheça o manifesto tech</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/conheca-o-manifesto-tech/"/>
        <id>https://gutocarvalho.net/conheca-o-manifesto-tech/</id>
            <category term="FalaGutera"/>

        <updated>2022-02-18T10:01:36-03:00</updated>
            <summary>
                <![CDATA[
                    <p>Manifesto para o mercado de tecnologia brasileiro</p>

                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Manifesto para o mercado de tecnologia brasileiro</p>

<p>Ele foi lançado recentemente e confesso que ainda estou refletindo sobre ele, mas já dá para ver que existem empresas muito fortes tentando dar uma direção para contrações e  também discutir importantes mudanças de cultura nas empresas.<br><br>Vai lá e tire suas próprias conclusões:<br><br><a href="https://manifestotech.org/">https://manifestotech.org/</a><br><br>[s]<br>Guto</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Kuma.io, um projeto para ficar de olho!</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/kuma-um-projeto-para-ficar-de-olho/"/>
        <id>https://gutocarvalho.net/kuma-um-projeto-para-ficar-de-olho/</id>
            <category term="MindNotes"/>

        <updated>2022-02-18T09:55:18-03:00</updated>
            <summary>
                <![CDATA[
                    O kuma é um service mesh que roda em cima do envoy.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>O kuma é um service mesh que roda em cima do envoy.</p>
<hr>
<p>Me siga no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a> e acompanhe meus posts sobre Kubernetes, Cloud Native e CI/CD.</p>
<p>Aproveite e siga também a <a href="https://twitter.com/CDeliveryFdn">CD Foundation</a> e <a href="https://twitter.com/cloudnativefdn">Cloud Native Foundation</a>.</p>
<hr>
<p>O kuma funciona no kubernetes, no openshit e também em ambiente de virtual machines e aparentemente suporta múltiplos meshs em um mesmo cluster.</p>
<p>Características de segurança:</p>
<ul>
<li>Mesh / Muli-mesh</li>
<li>Mutual TLS (MTLS)</li>
<li>Traffic Permissions</li>
</ul>
<p>Características de controle de tráfego:</p>
<ul>
<li>Traffic Route &amp; Control</li>
<li>Health Check</li>
<li>Observability</li>
<li>Service Discovery</li>
<li>Faulty Injection</li>
<li>Circuit Breaker</li>
<li>Rate Limit</li>
<li>Retries</li>
<li>Virtual Onbound</li>
</ul>
<p>Características de observabilidade:</p>
<ul>
<li>Traffic Metrics</li>
<li>Service Map</li>
<li>Traffic Trace</li>
<li>Traffic Log</li>
</ul>
<p>O Kuma foi construído em volta do projeto Envoy e traz embarcado o Kong Gateway.</p>
<p>Uma das coisas interessantes que li sobre o projeto é que tem a  capacidade de funcionar multi-cluster, multi-cloud e multi-zone na mesma cloud.</p>
<p>Ele também traz um dashboard bem intuitivo para trabalhar.</p>
<p>Conversei com alguns Cloud Engineers que falaram muito bem dele.</p>
<p>Tá na fila para estudar!</p>
<p>[s]<br>
Guto</p>
<p>–</p>
<p>Este post é do tipo #MindNotes, entenda <a href="https://gutocarvalho.net/o-que-sao-mindnotes/">aqui</a>.</p>
<p>Se gostou manda um alo no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a>.</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Minha stack como Cloud Engineer em 2022</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/minha-stack-com-cloud-engineer-em-20022/"/>
        <id>https://gutocarvalho.net/minha-stack-com-cloud-engineer-em-20022/</id>
            <category term="MindNotes"/>

        <updated>2022-02-18T09:56:09-03:00</updated>
            <summary>
                <![CDATA[
                    Projeto que uso no dia a dia como Cloud Engineer. Me siga&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Projeto que uso no dia a dia como Cloud Engineer.</p>
<hr>
<p>Me siga no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a> e acompanhe meus posts sobre Kubernetes, Cloud Native e CI/CD.</p>
<p>Aproveite e siga também a <a href="https://twitter.com/CDeliveryFdn">CD Foundation</a> e <a href="https://twitter.com/cloudnativefdn">Cloud Native Foundation</a>.</p>
<hr>
<p>Bora lá descobrir!</p>
<h4 id="para-orquestrar-infra-em-provedores-de-nuvem">Para orquestrar Infra em provedores de nuvem?</h4>
<ul>
<li>Terraform</li>
</ul>
<h4 id="para-orquestrar-um-sistema-operacional">Para orquestrar um sistema operacional?</h4>
<ul>
<li>Ansible</li>
</ul>
<h4 id="qual-plataforma-eu-usoprefiro-para-rodar-apps">Qual plataforma eu uso/prefiro para rodar APPs?</h4>
<ul>
<li>Kubernetes</li>
</ul>
<h4 id="qual-meu-k8s-gerenciado-preferido">Qual meu K8S Gerenciado preferido?</h4>
<p>Em primeiro lugar!</p>
<ul>
<li>EKS</li>
</ul>
<p>Uma nova opção que tem se mostrado econômica e viável</p>
<ul>
<li>Kubernetes da Jelastic que uso via <a href="https://saveincloud.com/pt">https://saveincloud.com/pt</a></li>
</ul>
<h4 id="qual-distribuição-preferida-para-kubernetes-onprem">Qual distribuição preferida para Kubernetes OnPrem?</h4>
<ul>
<li>RKE</li>
</ul>
<h4 id="qual-distribuição-preferida-para-kubernetes-leveedgeiot">Qual distribuição preferida para Kubernetes Leve/Edge/IoT?</h4>
<ul>
<li>K3S</li>
</ul>
<h4 id="runtime-para-kubernetes">Runtime para Kubernetes?</h4>
<ul>
<li>Docker</li>
</ul>
<h4 id="pretente-mudar-para-algum-outro-runtime">Pretente mudar para algum outro runtime?</h4>
<p>Sem dúvida estou de olho em alternativas, são elas:</p>
<ul>
<li>CRI-O</li>
<li>Containerd</li>
</ul>
<h4 id="quais-dashboards-preferidos-para-k8s">Quais dashboards preferidos para K8S?</h4>
<ul>
<li>LENS para Desktop</li>
<li>Rancher como Dashboard Web</li>
<li>K9S para terminal</li>
</ul>
<p>E estou de olho no projeto abaixo</p>
<ul>
<li>Kubevious</li>
</ul>
<h4 id="o-que-usa-para-validar-seus-manifestos-yaml-">O que usa para validar seus manifestos YAML ?</h4>
<ul>
<li>Kubeval</li>
</ul>
<h4 id="para-empacotar-apps-para-kubernetes">Para empacotar APPs para Kubernetes?</h4>
<ul>
<li>HELM</li>
</ul>
<h4 id="o-que-usa-para-monitorar-o-cluster-e-apps-em-seu-kubernetes">O que usa para monitorar o cluster e apps em seu Kubernetes?</h4>
<ul>
<li>Kube-prometheus-stack (Node Exporter + Prometheus + Grafana)</li>
</ul>
<h4 id="e-como-storage-de-blocos-distribuído-rodando-no-cluster">E como storage de blocos distribuído rodando no cluster?</h4>
<p>Quando existe a necessidade eu uso</p>
<ul>
<li>Longhorn</li>
</ul>
<h4 id="e-como-storage-de-objetos-rodando-no-cluster">E como storage de objetos rodando no cluster?</h4>
<p>Quando existe a necessidade eu uso</p>
<ul>
<li>Minio</li>
</ul>
<h4 id="e-para-fazer-backup">E para fazer backup?</h4>
<ul>
<li>Velero</li>
</ul>
<h4 id="e-como-ferramenta-de-registry">E como ferramenta de registry?</h4>
<ul>
<li>Harbor</li>
</ul>
<h4 id="o-que-usa-para-gerenciar-certificados-no-kubernetes">O que usa para gerenciar certificados no Kubernetes?</h4>
<ul>
<li>CertManager + LetsEncrypt</li>
</ul>
<h4 id="o-quer-usa-para-service-mesh-no-kubernetes">O quer usa para service mesh no Kubernetes?</h4>
<p>Quando o projeto pede, vamos de</p>
<ul>
<li>Istio</li>
</ul>
<h4 id="o-que-usa-no-kubernetes-para-autoscaling">O que usa no kubernetes para autoscaling?</h4>
<p>O que já vem pronto</p>
<ul>
<li>HPA</li>
</ul>
<p>E para complementar?</p>
<ul>
<li>Keptn ou</li>
<li>Kaperter</li>
</ul>
<h4 id="o-que-usa-para-manter-a-qualidade-da-apps-rodando">O que usa para manter a qualidade da APPs rodando?</h4>
<p>Quando o projeto pede, vamos de</p>
<ul>
<li>Keda</li>
</ul>
<h4 id="o-que-usa-para-centralizar-logs-do-cluster-e-suas-apps">O que usa para centralizar logs do cluster e suas APPs?</h4>
<ul>
<li>Grafana Loki</li>
</ul>
<h4 id="qual-tecnologia-de-cicd-usa-hoje-em-dia">Qual tecnologia de CI/CD usa hoje em dia?</h4>
<p>Difícil apontar uma, normalmente eu vou onde me sinto confortável:</p>
<ul>
<li>GitLab CI ou</li>
<li>GitHub Actions</li>
</ul>
<p>Contudo estou inclinado em usar coisas mais Cloud Native e tenho estudado:</p>
<ul>
<li>ArgoCD</li>
<li>Flux</li>
<li>Tekton</li>
<li>Werf</li>
</ul>
<h4 id="o-que-usa-para-checar-a-sanidadesaúde-do-cluster">O que usa para checar a sanidade/saúde do cluster?</h4>
<ul>
<li>Popeye</li>
<li>Kube Bench</li>
</ul>
<h4 id="e-para-checar-aspectos-de-segurança">E para checar aspectos de segurança?</h4>
<ul>
<li>Kuber Hunter</li>
</ul>
<h4 id="e-no-caso-de-chaos-test">E no caso de Chaos Test?</h4>
<p>É bem nicho, mas tem essa ferramentinha simples e bacana</p>
<ul>
<li>ChaosKube</li>
</ul>
<h4 id="para-api-gateway">Para API Gateway?</h4>
<p>Quando o projeto pede, vamos de</p>
<ul>
<li>Kong</li>
</ul>
<h4 id="para-tracing">Para Tracing</h4>
<p>To de olho no </p>
<ul>
<li>Grafana Tempo + OpenTelemetry</li>
</ul>
<h2 id="amarrando-as-pontas">Amarrando as pontas</h2>
<p>Acho que é isso. A lista é longa e mostra como o Cloud Enginner tem que ser flexível e estudar muito para integrar tudo e manter sua aplicação rodando em nuvem da forma mais estável, saudável, performática e segura possível ;)</p>
<p>Volto para atualizar se tiver mais alguma coisa em mente!</p>
<p>[s]<br>
Guto</p>
<p>–</p>
<p>Este post é do tipo #MindNotes, entenda <a href="https://gutocarvalho.net/o-que-sao-mindnotes/">aqui</a>.</p>
<p>Se gostou manda um alo no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a>.</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Live com Save&#x27;In&#x27;Cloud no dia 22 de Fevereiro</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/live-com-saveincloud-no-dia-22-de-fevereiro/"/>
        <id>https://gutocarvalho.net/live-com-saveincloud-no-dia-22-de-fevereiro/</id>
            <category term="Eventos"/>

        <updated>2022-02-17T17:13:45-03:00</updated>
            <summary>
                <![CDATA[
                    <p>Pessoal estarei com a Save'in'Cloud falando sobre Kubernetes e Cloud Native. </p>

                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Pessoal estarei com a Save'in'Cloud falando sobre Kubernetes e Cloud Native. </p>

<p>A live começará as 19 horas no horário de Brasília.<br><br>Participe e aproveite para tirar suas dúvidas!<br><br><a href="https://cloud.saveincloud.com.br/lp/meetup-kubernetes-22-02/" target="_blank" rel="noopener noreferrer">https://cloud.saveincloud.com.br/lp/meetup-kubernetes-22-02/</a><br><br>[s]<br>Guto</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title> Entendendo o Kubernetes &amp; Cloud Native</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/entendendo-o-kubernetes-and-cloud-native/"/>
        <id>https://gutocarvalho.net/entendendo-o-kubernetes-and-cloud-native/</id>
            <category term="TLDR"/>

        <updated>2022-02-17T08:13:18-03:00</updated>
            <summary>
                <![CDATA[
                    Bora entender isso e ficar na mesma página? Vem com a gente!&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Bora entender isso e ficar na mesma página? Vem com a gente!</p>
<p>Me siga no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a> e acompanhe meus posts sobre Cloud Native e CI/CD.</p>
<p>Siga a <a href="https://twitter.com/CDeliveryFdn">CD Foundation</a> e <a href="https://twitter.com/cloudnativefdn">Cloud Native Foundation</a> no twitter.</p>
<h2 id="o-que-é">O que é?</h2>
<p>O kubernetes é um orquestrador de containers que oferece meios para você executar, escalar e atualizar seu software de forma simples e eficiente.</p>
<p>Com o kubernetes podemos automatizar a implantação de nosso software integrando nossa pipeline com um cluster de containers, conseguindo assim entregar nosso software de maneira rápida e controlada.</p>
<h2 id="origens">Origens</h2>
<p>Em 2014 o google liberou um projeto open source interno que orquestrava containers, ele foi a base para o Kubernetes.</p>
<h3 id="curiosidades-sobre-as-origens">Curiosidades sobre as origens</h3>
<p>No Google, internamente o projeto se chamava BORG.</p>
<p>O projeto BORG foi reescrito em GO e foi rebatizado de Kubernetes.</p>
<p>Kubernetes significa timoneiro – em grego, aquele que pilota uma embarcação.</p>
<p>A primeira release do kubernetes foi lançada em 7 de Junho de 2014.</p>
<h2 id="cloud-native-computing-foundation-ou-cncf">Cloud Native Computing Foundation ou CNCF</h2>
<p>O Google queria algum lugar para hospedar não só o projeto Kubernetes em si, mais um lugar em que todos pudessem contribuir com o projeto e criar novas soluções para esse segmento de aplicações rodando em containers.</p>
<p>Com essa ideia em mente, o Google entrou em contato com a Linux Foundation para criar uma estrutura que pudesse receber esse projeto e fomentar tecnologias e soluções ligadas a esse novo universo de containers.</p>
<p>A Linux Foundation criou então a CNCF, Cloud Native Computing Foundation para fomentar o desenvolvimento do Kubernetes e de tecnologias com foco em containers. O Termo Cloud Native foi cunhado e passou a ser utilizado para se referir aplicações desta natureza.</p>
<p>A CNCF foi fundada e teve seu anúncio junto com o lançamento da versão 1.0 do Kubernetes em 21 de Julho de 2015.</p>
<h2 id="como-funciona-">Como funciona ?</h2>
<p>O Kubernetes ou K8S como é chamado de forma abreviada é um orquestrador  que foi desenhado para gerenciar workloads de containers e serviços de forma automatizada, utilizando configuração declarativa que usa o estrutura e formato de dados do projeto YAML.</p>
<p>Isso significa que podemos definir o estado desejado de funcionamento de nosso cluster e também das aplicações rodando neste, apenas utilizando convenções em YAML. Os operadores do cluster vão ler essas definições e garantir esse estado, fazendo modificações quando for necessário.</p>
<p>O kubernetes oferece:</p>
<ul>
<li>Serviço de descoberta</li>
<li>Serviço de balanceamento de carga</li>
<li>Serviço de proxy</li>
<li>Gerenciamento de redes e sub-redes</li>
<li>Gerenciamento de DNS</li>
<li>Orquestração de storage para os containers</li>
<li>Automação de rollouts ou rollbacks de suas aplicações</li>
<li>Gerenciamento dos certificados com geração e renovação automática</li>
<li>Gerenciamento de configuraçoes (configmaps)</li>
<li>Gerenciamento de segredos (secrets)</li>
<li>Gerenciamento de jobs (cronjobs)</li>
<li>Gerenciamento de limites de recursos para cada container</li>
<li>Self-healing, ele reinicia ou substitiu um container em caso de falha</li>
</ul>
<p>Em resumo, o kubernetes vai oferecer tudo que é necessário para sua aplicação rodar e ser utilizada por seus usuários.</p>
<h3 id="por-que-chamam-o-k8s-de-os-de-datacenter">Por que chamam o K8S de OS de Datacenter?</h3>
<p>Em alguns treinamentos ou palestras você pode ouvir o pessoal falando que o Kuberneters – antigo BORG – é um sistema operacional de datacenter, e tudo bem, faz sentido falar isso.</p>
<p>Se obervarmos com cuidado, vamos ver que o kubernetes oferece tudo que um software precisa, indo do endereço ip, rede, storage, balanceamento, dns, certificado, configurações, segredos, em suma, ele traz tudo que um datacenter ofereceria para uma aplicação em um lugar só, e essa é beleza e a força do projeto.</p>
<p>É de fato um datacenter inteiro em uma única solução.</p>
<h2 id="quais-os-benefícios">Quais os benefícios?</h2>
<p>Como o kubernetes oferece tudo que sua aplicação precisa, você tem mais tempo para se preocupar com o negócio, isso pode melhorar sua produtividade e reduzir tempo gasto com configurações comuns geralmente executadas em sua infraestrutura clássica.</p>
<p>O cluster kubernetes te ajuda a usar os recursos computacionais de forma mais eficiente. Como tudo roda em containers, você consegue compartilhar mais recursos computacionais com diferentes aplicações sendo executadas no cluster.</p>
<p>O processo de entrega e o ciclo de desenvolvimento do software pode ser sensivelmente reduzido depois que você integrar o cluster ao seu processo de desenvolvimento.</p>
<p>Uma vez que sua aplicação está rodando em Kubernetes, você conseguirá rodá-la praticamente em quaisquer cloud pública que suporte kubernetes. Essa portabilidade é muito importante e oferece a capacidade de seu software funcionar em diferentes clouds, podendo escolher aquela com melhor custo, ou até replicar sua aplicação em provedores diferentes para garantir mais disponibilidade.</p>
<p>Ao usar aplicações dentro do cluster, você conseguirá reduzir sensivelmente o custo de sua conta em uma Cloud Pública, isso acontece pois o Kubernetes já traz a maioria dos recursos de forma nativa, reduzindo assim dua despesa no final do mês.</p>
<p>O Kubernetes é o orquestrador líder de mercado, é comprovadamente estável, é mantido por diversas empresas incluindo o Google e foi testado em produção em diversos cenários com sucesso, o que nos garante que não estamos embarcando em uma aventura com uma tecnologia com pouca maturidade. Existem muitos cases de aplicações de missão crítica rodando em clusters Kubernetes, se é eficiente para eles, é eficiente para você.</p>
<h2 id="é-realmente-seguro">É realmente seguro?</h2>
<p>Sim é seguro, contudo, como qualquer outro software ou plataforma a segurança tem que fazer parte de suas preocupações desde o momento do design de seu cluster.</p>
<p>Coisas como:</p>
<ul>
<li>Escolher uma distribuição kubernetes certificada pela CNCF</li>
<li>Escolher um OS base mínimo, com foco em K8S</li>
<li>Remover credenciais e acessos desnecessários</li>
<li>Evitar rodar qualquer coisa com privilégios de ROOT</li>
<li>Seguir todas as boas práticas de segurança para clusters K8S</li>
<li>Fazer o hardeding de seus clusters</li>
<li>Instalar ferramentas para verificar a segurança de seu cluster regularmente</li>
<li>Centralizar e acompanhar os logs do cluster e das APPs</li>
<li>Centralizar e acompanhar as métricas do cluster e das APPs</li>
<li>Inserir segurança no processo de desenvolvimento de suas APPS desde o dia zero</li>
</ul>
<p>Seguindo essas dicas você terá tanto um cluster quando APPs seguras rodando nele.</p>
<h2 id="consigo-rodar-meu-software-nele">Consigo rodar meu software nele?</h2>
<p>Consegue sim, mesmo se for um monolito.</p>
<p>Diferente do que muitos pensam o Kubernetes pode rodar qualquer software que esteja embarcado em um container, seja um monolito, um microserviço ou uma API.</p>
<p>Obviamente se você estiver iniciando o desenvolvimento do seu software o ideal é pensar em decompor sua solução em microserviços que se comunicam via API, pensar em aplicações do tipo stateless, pensar em aplicações que podem rodar em múltiplos nodes e pods, pensar em uso de banco de dados externo, pensar em persistência e armazenamento de arquivos usando storage de objetos – estilo S3 – dentre outras boas práticas de APPs Cloud Native. </p>
<p>Seguindo essas  dicas, você terá de fato uma aplicação Cloud Native que poderá usar o melhor do Kubernetes. Sua aplicação conseguirá escalar horizontalmente e atender a demanda crescente de seus usuários.</p>
<h2 id="consigo-rodar-kubernetes-on-premisses">Consigo rodar Kubernetes on-premisses?</h2>
<p>Sim consegue, existem excelentes distribuições para rodar On-Premisses, uma delas é o RKE da Rancher.</p>
<p>Quando falamos de on-premisses, precisamos pensar em um desenho robusto de nosso cluster, lembrar que precisamos de redudância entre hypervisors, backup real e eficiente, load balancer L4, centralização de logs, monitoramento, avaliação de métricas e performance, gerenciamento de certificados dentre outras coisas que precisam ser configuradas e levadas em conta para termos um cluster on-premisses rodando de forma segura, estável e performática.</p>
<h2 id="consigo-rodar-kubernetes-em-meu-provedor-de-nuvem">Consigo rodar Kubernetes em meu provedor de nuvem?</h2>
<p>Sim consegue também, rodando em instâncias virtuais da mesma forma como rodaria on-premisses ou usando serviços gerenciados do provedor.</p>
<h2 id="vale-a-pena-usar-o-kubernetes-gerenciado">Vale a pena usar o kubernetes gerenciado?</h2>
<p>Vale muito, especialmente se seu time é mais focado em desenvolvimento do que em infraestrutura.</p>
<p>No caso de plataformas gerenciadas como EKS da AWS, GKS do Google, AKS da Azure, OKE da Oracle  ou mesmo o Kubernetes gerenciado da Jelastic/SaveinCloud toda a parte da configuração e funcionamento do cluster, em especial os nós de controle, são mantidos pelo provedor, você só se preocupa com seus workloads e os nós do tipo worker que serão registrados no cluster que foi criado.</p>
<p>Com um kubernetes gerenciado você pode focar em seu negócio e deixar a infra com o provedor, é o melhor cenário para uma empresa com um time pequeno de desenvovledores ou um time sem engenheiros de nuvem.</p>
<h2 id="o-que-são-aplicações-cloud-native">O que são aplicações Cloud Native?</h2>
<p>Aplicações Cloud Native são aquelas que já são construídas pensando em se beneficiar de recursos da computação em nuvem. E neste caso, isso esta intimamente ligado ao uso de containers e a orquestração destes.</p>
<p>Características de aplicações Cloud Native</p>
<ul>
<li>Uso da Cultura DevOps no dia-a-dia do time do produto</li>
<li>Uso de métodos ágeis no desenvolvimento do produto</li>
<li>Uso de arquitetura de microserviços e API-First</li>
<li>Foco em oferecer métricas de seus componentes desde o dia zero</li>
<li>Foco em oferecer amplo monitoramento de suas features desde o dia zero</li>
<li>Foco em portabilidade e execução multi-cloud desde o dia zero</li>
<li>Abstração de sistema operacional com uso de containers</li>
<li>Uso de pipelines de integração contínua no processo de desenvolvimento</li>
<li>Uso de pipelines de entrega contínua para publicar seu software</li>
<li>Software desenhado para rodar como “Stateless”</li>
<li>Software pensado para uso de storage de objetos ao invés de filesystem</li>
<li>Software pensado para funcionar em cenários de escalabilidade horizontal</li>
<li>Software pensado para rodar em clusters de containers como kubernetes ou nomad</li>
<li>Software pensado para ser resiliente a falhas, onde possamos usar chaos engineering para testá-lo</li>
<li>Foco na rápida entrega de atualizações e novidades para seus usuários</li>
<li>Foco na capacidade de fazer rollback de forma fácil e simples caso seja nesessário</li>
</ul>
<p>Eu acrescentaria ainda:</p>
<ul>
<li>Suporte nativo a Kubernetes e Docker</li>
</ul>
<p>Basicamente são essas as características que representam uma APP Cloud Native hoje, pelo menos em minha humilde opinião.</p>
<h2 id="amarrando-as-pontas">Amarrando as pontas</h2>
<p>Espero que eu tenha conseguido explicar o projeto Kubernetes e o conceito de Cloud Native para você.</p>
<p>Em breve falaremos da arquitetura do Kubernetes! :)</p>
<p>[s]<br>
Guto</p>
<hr>
<p>Este post é do tipo #TLDR, entenda <a href="https://gutocarvalho.net/o-que-sao-tldrs/">aqui</a>.</p>
<p>Se gostou manda um alo no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a>.</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>CFP para CdCon 2022</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/cfp-para-cdcon-2022/"/>
        <id>https://gutocarvalho.net/cfp-para-cdcon-2022/</id>
            <category term="MindNotes"/>

        <updated>2022-02-15T15:58:17-03:00</updated>
            <summary>
                <![CDATA[
                    Pessoal, faltam 5 dias para fechar a CFP para a CdCON Texas&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Pessoal, faltam 5 dias para fechar a CFP para a CdCON Texas 2022.</p>
<p>Bora enviar propostas!<br><br><a href="https://events.linuxfoundation.org/cdcon/program/cfp/">https://events.linuxfoundation.org/cdcon/program/cfp</a></p>
<p>Visite o site da CDCON<br><br><a href="https://events.linuxfoundation.org/cdcon">https://events.linuxfoundation.org/cdcon</a></p>
<p>[s]<br>Guto</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Conheça o Cloud Native Trail Map</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/conheca-o-cloud-native-trail-map/"/>
        <id>https://gutocarvalho.net/conheca-o-cloud-native-trail-map/</id>
            <category term="MindNotes"/>

        <updated>2022-02-16T08:55:52-03:00</updated>
            <summary>
                <![CDATA[
                    <p>Saiba como iniciar sua jornada <a href="https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png"><strong>Cloud Native</strong></a>!</p>

                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Saiba como iniciar sua jornada <a href="https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png"><strong>Cloud Native</strong></a>!</p>

<p>Me siga no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a> e acompanhe meus posts sobre Cloud Native e CI/CD.</p>
<p>Siga a <a href="https://twitter.com/CDeliveryFdn">CD Foundation</a> e <a href="https://twitter.com/cloudnativefdn">Cloud Native Foundation</a> no twitter.</p>
<p>Revisor: <a href="https://twitter.com/rkpegoraro">Ricardo Pegoraro</a></p>
<hr>
<figure class="post__image"><br>Esse mapa sugere um caminho com 10 passos para você entrar no mundo Cloud Native sempre utilizando tecnologias open source para sua jornada.<br><br>Abaixo do mapa eu comento livremente passo a passo! :)<br><br><img loading="lazy"  src="https://gutocarvalho.net/media/posts/111/CNCF_TrailMap_2022-02-15-2.png" sizes="(min-width: 61.3125em) 50vw, 100vw" srcset="https://gutocarvalho.net/media/posts/111/responsive/CNCF_TrailMap_2022-02-15-2-xs.png 300w ,https://gutocarvalho.net/media/posts/111/responsive/CNCF_TrailMap_2022-02-15-2-sm.png 480w ,https://gutocarvalho.net/media/posts/111/responsive/CNCF_TrailMap_2022-02-15-2-md.png 768w"  alt="Cloud Native Trail Map" width="7653" height="8869"></figure>
<p class="part" title="" data-startline="10" data-endline="10" data-position="283" data-size="0" data-original-title="" aria-describedby="popover429228"><strong data-position="283" data-size="0"><span data-position="285" data-size="24">Passo 1: Containerização</span></strong></p>
<div id="popover429228" class="popover selection-popover top in">
<div class="arrow"><span style="color: var(--text-editor-body-color); font-family: var(--font-base); font-size: inherit; font-weight: var(--font-weight-normal);"><br>Aqui nesse passo a ideia é atuar para que sua aplicação rode em containers. No futuro é interessante pensar em desacoplar sua APP para rodar pequenas partes do seu software de forma separada usando o conceito de <strong>microserviços</strong>.</span></div>
</div>
<p class="part" data-startline="14" data-endline="14" data-position="542" data-size="0"><span data-position="541" data-size="31">Normalmente nesse passo usamos </span><strong data-position="572" data-size="0"><span data-position="574" data-size="6">Docker </span></strong>e escrevemos os primeiros<span data-position="582" data-size="12"> </span><strong data-position="594" data-size="0"><span data-position="596" data-size="11">Dockerfiles</span></strong><span data-position="609" data-size="1">.</span></p>
<p class="part" data-startline="16" data-endline="16" data-position="613" data-size="0"><strong data-position="613" data-size="0"><span data-position="615" data-size="36">Passo 2: Construir sua esteira CI/CD</span></strong></p>
<p class="part" data-startline="18" data-endline="18" data-position="655" data-size="0"><span data-position="655" data-size="168">Neste passo a ideia é criar uma esteira para que essa faça o build da sua imagem automaticamente quando houver uma atualização no seu código. Essa esteira deve fazer o </span><strong data-position="823" data-size="0"><span data-position="825" data-size="5">build</span></strong><span data-position="832" data-size="2">, </span><strong data-position="834" data-size="0"><span data-position="836" data-size="6">testar</span></strong><span data-position="844" data-size="19"> sua app e fazer o </span><strong data-position="863" data-size="0"><span data-position="865" data-size="6">deploy</span></strong><span data-position="873" data-size="6"> para </span><strong data-position="879" data-size="0"><span data-position="881" data-size="7">staging</span></strong><span data-position="890" data-size="15"> e depois para </span><strong data-position="905" data-size="0"><span data-position="907" data-size="8">produção</span></strong><span data-position="917" data-size="59">, já rodando sua aplicação em uma plataforma de containers.</span></p>
<p class="part" data-startline="20" data-endline="20" data-position="978" data-size="0"><span data-position="978" data-size="49">Aqui algumas pessoas já estão usando um pouco de </span><strong data-position="1027" data-size="0"><span data-position="1029" data-size="14">docker-compose</span></strong><span data-position="1045" data-size="32"> para facilitar o uso de Docker.</span></p>
<p class="part" data-startline="22" data-endline="22" data-position="1079" data-size="0"><span data-position="1079" data-size="64">Um excelente solução para construir sua esteira é usar o projeto <strong>ArgoCD</strong>.</span></p>
<p class="part" data-startline="24" data-endline="24" data-position="1146" data-size="0"><strong data-position="1145" data-size="0"><span data-position="1147" data-size="37">Passo 3: Começar a orquestrar sua APP</span></strong></p>
<p class="part" data-startline="26" data-endline="26" data-position="1189" data-size="0"><span data-position="1188" data-size="286">Aqui a ideia é ir além do Docker, começando a utilizar um orquestrador de containers como Kubernetes ou Nomad. Utilizando um orquestrador você já vai rodar suas apps em um ambiente mais robusto, com estrutura de cluster com diversos benefícios como disponibilidade, escalabilidade, descoberta e muito mais.</span></p>
<p class="part" data-startline="28" data-endline="28" data-position="1477" data-size="0"><span data-position="1476" data-size="144">É importante escolher uma distribuição certificada pela CNCF e usar ferramentas adequadas para armazenar suas imagens e empacotar sua aplicação.</span></p>
<p class="part" data-startline="30" data-endline="30" data-position="1623" data-size="0"><span data-position="1622" data-size="151">Sugestões de ferramentas são <strong>Kubernetes</strong> para o cluster de containers, <strong>HELM</strong> para empacotamento de suas apps e <strong>Harbor</strong> para armazenamento de suas imagens.</span></p>
<p class="part" data-startline="32" data-endline="32" data-position="1776" data-size="0"><span data-position="1775" data-size="228">Mudando para um cluster você terá que ajustar suas esteiras para que o deploy seja feito neste novo ambiente, na esteira você também vai adicionar um passo para armazenar a imagem no <strong>registry</strong> e empacotar sua APP no formato <strong>HELM</strong>.</span></p>
<p class="part" data-startline="34" data-endline="34" data-position="2006" data-size="0"><strong data-position="2005" data-size="0"><span data-position="2007" data-size="34">Passo 4: Observabilidade e Análise</span></strong></p>
<p class="part" data-startline="36" data-endline="36" data-position="2046" data-size="0"><span data-position="2045" data-size="312">Do passo 1 ao passo 3 você estará se preparando para entrar no universo Cloud Native, se chegou no passo 3 já é uma grande vitória. Entrar no passo 4 significa que você já atingiu uma certa maturidade para rodar seu software e agora precisa de dados para melhorar e manter tudo funcionando da forma mais adequada.</span></p>
<p class="part" data-startline="38" data-endline="38" data-position="2361" data-size="0"><span data-position="2359" data-size="73">Aqui vamos pensar em monitoração, métricas, logs e tracing de aplicações.</span></p>
<p class="part" data-startline="40" data-endline="40" data-position="2436" data-size="0"><span data-position="2434" data-size="204">Para monitoramento geralmente utilizamos o <strong>prometheus</strong> para coletar e consolidar os dados, o <strong>grafana</strong> para visualizar esses dados em dashboards, para logs podemos usar o <strong>fluentd</strong> e para tracing o <strong>opentracing</strong>.<br><br>Usamos essas ferramenta para ver se tudo está funcionando, para avaliar a saúde de nossa aplicação e sua performance, afinal, não tem como melhorar algo se não temos métricas para comparar a evolução – ou regressão -  de alguma coisa.</span></p>
<p class="part" data-startline="42" data-endline="42" data-position="2642" data-size="0"><strong data-position="2640" data-size="0"><span data-position="2642" data-size="42">Passo 5: Service Proxy, Discovery and Mesh</span></strong></p>
<p class="part" data-startline="44" data-endline="44" data-position="2690" data-size="0"><span data-position="2688" data-size="201">Bom agora que já temos nossa APP rodando em um cluster Kubernetes, com pipeline para entregar software, monitoramento e métricas de nosso software é hora de pensarmos em usarmos mais de nossos clusters.</span></p>
<p class="part" data-startline="46" data-endline="46" data-position="2895" data-size="0"><span data-position="2891" data-size="175">Podemos explorar mais os recursos de serviço discovery, service mesh e load balancing, cada qual em seu quadrado para ajudar nossa aplicação a se manter consistente e escalar.</span></p>
<p class="part" data-startline="48" data-endline="48" data-position="3072" data-size="0"><span data-position="3068" data-size="74">As sugestões aqui são <strong>Envoy</strong> (Proxy), <strong>CoreDNS</strong> (Discovery) e <strong>Linkerd</strong> (Mesh).</span></p>
<p class="part in-view" data-startline="51" data-endline="51" data-position="3149" data-size="0"><strong data-position="3149" data-size="0"><span data-position="3151" data-size="34">Passo 6: Network Policy &amp; Security</span></strong></p>
<p class="part in-view" data-startline="53" data-endline="53" data-position="3189" data-size="0"><span data-position="3189" data-size="387">Pensar em rede segurança é importante, manter seu cluster seguro é essencial. O kubernetes oferece recursos muito flexíveis para fazer o design de sua rede interna, e além disso, temos excelentes ferramentas para tratar da segurança de nosso cluster, desde a segurança de acesso aos recursos do cluster, configurações do cluster indo até a avaliação de vulnerabilidades das APPs rodando.</span></p>
<p class="part in-view" data-startline="55" data-endline="55" data-position="3578" data-size="0"><span data-position="3578" data-size="62">APPs para ajudar: <strong>CNI</strong> (rede), <strong>OPA</strong> (Policy) e <strong>Falco</strong> (security).</span></p>
<p class="part in-view" data-startline="57" data-endline="57" data-position="3642" data-size="0"><strong data-position="3642" data-size="0"><span data-position="3644" data-size="46">Passo 7: Storage e Banco de dados distribuídos</span></strong></p>
<p class="part in-view" data-startline="59" data-endline="59" data-position="3694" data-size="0"><span data-position="3694" data-size="219">Quando a gente precisa de mais resiliência e disponibilidade para nossos bancos, rodar o banco no cluster começa a fazer muito sentido, em especial se compararmos com um banco rodando em uma arquitetura single-instance.</span></p>
<p class="part in-view" data-startline="61" data-endline="61" data-position="3915" data-size="0"><span data-position="3915" data-size="76">Temos tecnologias Cloud Native para por exemplo rodar bancos de dados com o </span><strong data-position="3991" data-size="0"><span data-position="3993" data-size="5">MySQL</span></strong><span data-position="4000" data-size="40"> de forma distribuída no cluster como o </span><strong data-position="4040" data-size="0"><span data-position="4042" data-size="6">Vitess</span></strong><span data-position="4050" data-size="30">, temos ainda projetos como o </span><strong data-position="4080" data-size="0"><span data-position="4082" data-size="11">CrunchyData</span></strong><span data-position="4095" data-size="30"> para rodar um ambiente HA de </span><strong data-position="4125" data-size="0"><span data-position="4127" data-size="8">Postgres</span></strong><span data-position="4137" data-size="27"> (completo) em nosso cluster.</span></p>
<p class="part in-view" data-startline="63" data-endline="63" data-position="4166" data-size="0"><span data-position="4166" data-size="125">A parte de persistência de dados também ganha uma atenção especial, no caso de banco de dados ou de qualquer outra aplicação </span><strong data-position="4291" data-size="0"><span data-position="4293" data-size="10">“stateful”</span></strong><span data-position="4305" data-size="31"> que necessite persistir dados.</span></p>
<p class="part in-view" data-startline="65" data-endline="65" data-position="4339" data-size="0"><span data-position="4339" data-size="71">Para atender a demanda de persistir dados temos soluções robustas como </span><strong data-position="4410" data-size="0"><span data-position="4412" data-size="8">LongHorn</span></strong><span data-position="4422" data-size="3"> e </span><strong data-position="4425" data-size="0"><span data-position="4427" data-size="7">OpenEBS</span></strong><span data-position="4436" data-size="21"> que são soluções de </span><strong data-position="4457" data-size="0"><span data-position="4459" data-size="13">block-storage</span></strong><span data-position="4474" data-size="85"> que podem ser utilizadas combinados com o Vitess, CrunchyData ou qualquer outra app.</span></p>
<p class="part in-view" data-startline="67" data-endline="67" data-position="4561" data-size="0"><span data-position="4561" data-size="48">Temos ainda soluções de storage de objetos como </span><strong data-position="4609" data-size="0"><span data-position="4611" data-size="5">Minio</span></strong><span data-position="4618" data-size="3"> e </span><strong data-position="4621" data-size="0"><span data-position="4623" data-size="4">CEPH</span></strong><span data-position="4629" data-size="68"> que são compatíveis com aplicações S3-Like, dentre outras soluções.</span></p>
<p class="part in-view" data-startline="69" data-endline="69" data-position="4699" data-size="0"><span data-position="4699" data-size="130">Além de tecnologias de bancos de chave-valor como <strong>ETCd</strong> que consegue armazenar e distribuir dados através dos nós do nosso cluster.</span></p>
<p class="part in-view" data-startline="71" data-endline="71" data-position="4831" data-size="0"><strong data-position="4831" data-size="0"><span data-position="4833" data-size="28">Passo 8: Stream e mensageria</span></strong></p>
<p class="part in-view" data-startline="73" data-endline="73" data-position="4865" data-size="0"><span data-position="4865" data-size="191">Existem excelentes soluções como <strong>NATs</strong> e <strong>gRPC</strong> para rodar em nossos clusters. O gRPC é uma solução universal de framework RPC e o NATS é um sistema de mensageria que nasceu na era Cloud Native.</span></p>
<p class="part in-view" data-startline="75" data-endline="75" data-position="5058" data-size="0"><strong data-position="5058" data-size="0"><span data-position="5060" data-size="37">Passo 9: Container Registry e Runtime</span></strong></p>
<p class="part in-view" data-startline="77" data-endline="77" data-position="5101" data-size="0"><span data-position="5101" data-size="77">Armazenar imagens de suas aplicações e dependências se torna fácil com Harbor.</span></p>
<p class="part in-view" data-startline="79" data-endline="79" data-position="5180" data-size="0"><span data-position="5180" data-size="162">Quer experimentar algum outro runtime diferente de Docker? Temos opções como <strong>Containerd</strong>, e <strong>CRI-O</strong> que podem substituir a altura e manter seus padrões cloud-native sem perder código já feito para o Docker.</span></p>
<p class="part in-view" data-startline="81" data-endline="81" data-position="5344" data-size="0"><strong data-position="5344" data-size="0"><span data-position="5346" data-size="34">Passo 10: Distribuição de software</span></strong></p>
<p class="part in-view" data-startline="83" data-endline="83" data-position="5384" data-size="0"><span data-position="5384" data-size="121">Caso precise distribuir software de forma segura, o projeto <strong>Notary</strong>, baseado no <strong>TUF</strong> (The Update Framework) pode te ajudar.</span></p>
<p class="part in-view" data-startline="85" data-endline="85" data-position="5507" data-size="0"><strong>Quer ver o mapa atualizado?</strong></p>
<p class="part in-view" data-startline="87" data-endline="87" data-position="5536" data-size="0"><a href="https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png" target="_blank" rel="noopener"><span data-position="5536" data-size="79">https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png</span></a></p>
<p class="part in-view" data-startline="89" data-endline="90" data-position="5617" data-size="0"><span data-position="5617" data-size="3">[s]</span><br><span data-position="5621" data-size="4">Guto<br><br>--</span></p>
<p>Este post é do tipo #MindNotes, entenda <a href="https://gutocarvalho.net/o-que-sao-mindnotes/">aqui</a>.</p>
<p>Se gostou manda um alo no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a>.</p>
<p class="part in-view" data-startline="89" data-endline="90" data-position="5617" data-size="0"><span data-position="5621" data-size="4"> </span></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Conheça o Cloud Native Landscape</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/conheca-o-cloud-native-landscape/"/>
        <id>https://gutocarvalho.net/conheca-o-cloud-native-landscape/</id>
            <category term="MindNotes"/>

        <updated>2022-02-17T13:54:53-03:00</updated>
            <summary>
                <![CDATA[
                    <p>Entenda para que serve e como usar!</p>

                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Entenda para que serve e como usar!</p>

<p>Me siga no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a> e acompanhe meus posts sobre Cloud Native e CI/CD.</p>
<p>Siga a <a href="https://twitter.com/CDeliveryFdn">CD Foundation</a> e <a href="https://twitter.com/cloudnativefdn">Cloud Native Foundation</a> no twitter.</p>
<p>Revisor: <a href="https://twitter.com/rkpegoraro">Ricardo Pegoraro</a><br><br><br></p>
<hr>
<figure class="post__image"><br><br>Fala pessoa, tudo em paz?<br><br>Talvez você já tenha visto o Cloud Native Landscape, mas ainda tem dúvidas sobre ele.<br><br><img loading="lazy"  src="https://gutocarvalho.net/media/posts/112/Screen-Shot-2022-02-15-at-10.11.44.png" sizes="(min-width: 61.3125em) 50vw, 100vw" srcset="https://gutocarvalho.net/media/posts/112/responsive/Screen-Shot-2022-02-15-at-10.11.44-xs.png 300w ,https://gutocarvalho.net/media/posts/112/responsive/Screen-Shot-2022-02-15-at-10.11.44-sm.png 480w ,https://gutocarvalho.net/media/posts/112/responsive/Screen-Shot-2022-02-15-at-10.11.44-md.png 768w"  alt="" width="1917" height="876"></figure>
<p><strong>Para que serve isso?</strong><br><br>Esse landscape é um grande mapa de projetos que compõe esse universo <strong>Cloud Native</strong>, são centenas de <strong>projetos open source</strong> em constante expansão através de <strong>contribuições</strong> de suas <strong>comunidades</strong>.<br><br>O Landscape é uma grande vitrine de projetos. Essa vitrine te ajuda a encontrar soluções open source para seu projeto Cloud Native de forma simples e fácil.<br><br><strong>Como está organizado?</strong><br><br>O Landscape está separado em categorias e sub-categorias, sendo elas:<br><br>- <strong>App Definition And Development</strong><br>  - Database<br>  - Streaming &amp; Messaging<br>  - Application Definition &amp; Image Build<br>  - Continuous Integration &amp; Delivery<br><br><br>- <strong>Orchestration &amp; Management</strong><br>  - Scheduling &amp; Orchestration<br>  - Coordination &amp; Service Discovery<br>  - Remote Procedure Call<br>  - Service Proxy<br>  - API Gateway<br>  - Service Mesh<br><br>- <strong>Runtime</strong><br>  - Cloud Native Storage<br>  - Container Runtime<br>  - Cloud Native Network<br><br>- <strong>Provisioning</strong><br>  - Automation &amp; Configuration<br>  - Container Registry<br>  - Security &amp; Compliance<br>  - Key Management<br><br>- <strong>Special</strong><br>  - Kubernetes Certified Service Provider<br>  - Kubernetes Training Partner<br><br>- <strong>Plataform</strong><br>  - Certified Kubernetes Distribuition<br>  - Certified Kubernetes Hosted<br>  - Certified Kubernetes Installer<br><br>- <strong>Observabilty &amp; Analysis</strong><br>  - Monitoring<br>  - Logging<br>  - Tracing<br>  - Chaos Engineering<br><br><strong>Como usar?</strong><br><br>É simples, precisa de uma solução de <strong>storage</strong>, procure uma na seção de <strong>storage</strong>, precisa de um <strong>proxy</strong>, tem uma seção para isso, basta pesquisar, testar e encontrar a solução que se encaixa com seu projeto.<br><br><strong> Outros Landscapes<br></strong><br>E ainda temos dois projetos separados que também tem seus próprios landscapes<br>  <br>  - <strong><a href="https://landscape.cncf.io/serverless">Serverless</a></strong> Landscape<br>  - <strong><a href="https://landscape.cd.foundation/">CD.Foundation</a></strong> Landscape</p>
<p><strong>Bora para os sites?</strong><br><br>Acesse o <a href="https://landscape.cncf.io/">CNCF</a> Landspace<br>Acesse o <a href="https://landscape.cncf.io/serverless">Serverless</a> Landscape<br>Acesse o <a href="https://landscape.cd.foundation/">CD.Foundation</a> Landscape<br><br>[s]<br>Guto<br><br>--</p>
<p>Este post é do tipo #MindNotes, entenda <a href="https://gutocarvalho.net/o-que-sao-mindnotes/">aqui</a>.</p>
<p>Se gostou manda um alo no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a>.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Boas práticas GIT para pessoas e times</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/boas-praticas-git-para-pessoas-e-times/"/>
        <id>https://gutocarvalho.net/boas-praticas-git-para-pessoas-e-times/</id>
            <category term="TLDR"/>

        <updated>2022-02-16T17:17:23-03:00</updated>
            <summary>
                <![CDATA[
                    30 dicas especiais para Cloud Engineers. Para que seus commits não sejam&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>30 dicas especiais para Cloud Engineers.</p>
<h2 id="o-básico">O Básico</h2>
<h3 id="1-configure-corretamente-nome-e-e-mail">1. Configure corretamente nome e e-mail</h3>
<p>Para que seus commits <strong>não</strong> sejam gravados com autor “root” e-mail “root@root” configure esses valores iniciais assim que instalar seu GIT.</p>
<pre><code>$ git config --global user.name &quot;Nome Sobrenome&quot;
$ git config --global user.email &quot;email@domain.ext&quot;
</code></pre>
<p>Pode acontecer de ter que mudar de e-mail dependendo do projeto, nesse caso rode isso dentro do diretório do seu projeto para sobrescrever as configurações globais</p>
<pre><code>$ cd meu_projeto/
$ git config user.name &quot;Nome Sobrenome&quot;
$ git config user.email &quot;email@domain.ext&quot;
</code></pre>
<h3 id="2-configure-seu-editor-favorito-globalmente">2. Configure seu editor favorito globalmente</h3>
<p>Eu gosto de usar o VIM</p>
<pre><code> $ git config --global core.editor vim
</code></pre>
<h3 id="3-ative-o-autocorrect">3. Ative o autocorrect</h3>
<p>O autocorrect vai te ajudar nos erros mais comuns, afinal quem nunca digitou git stats o bramch né?</p>
<pre><code>$ git config --global help.autocorrect 10
</code></pre>
<p>olhe um exemplo quando digitamos BRAMCH ao invés de BRANCH</p>
<pre><code>$ git bramch
WARNING: You called a Git command named &#39;bramch&#39;, which does not exist.
Continuing in 1.0 seconds, assuming that you meant &#39;branch&#39;.
dev
prod
* main
</code></pre>
<p>olhe um exemplo quando digitamo STATS ao invés de STATUS</p>
<pre><code>$ git stats
WARNING: You called a Git command named &#39;stats&#39;, which does not exist.
Continuing in 1.0 seconds, assuming that you meant &#39;status&#39;.
On branch gh-pages
nothing to commit, working tree clean
</code></pre>
<p>É bastante útil não é?</p>
<p>O valor <strong>10</strong> declara 10x10 décimos de segundo, o mesmo que 1 segundo e por aí vai. Caso queira que corrija automaticamente sem aguardar, use o valor 1.</p>
<pre><code>$ git config --global help.autocorrect 1
</code></pre>
<p>Dessa forma ele vai digitar o comando para você, veja mais detalhes no link abaixo</p>
<ul>
<li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_code_help_autocorrect_code">https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_code_help_autocorrect_code</a></li>
</ul>
<h4 id="como-desligar-o-autocorrect">como desligar o autocorrect?</h4>
<pre><code>$ git config --global --unset help.autocorrect
</code></pre>
<h3 id="4-use-uma-versão-atualizada-do-git">4. Use uma versão atualizada do GIT</h3>
<p>Normalmente o GIT que vem nas distribuições linux é bem antigo então é uma boa ideia atualizar se quer usar recursos mais recentes e versões com mais performance.</p>
<p>Se estiver no mac o Homebrew pode ajudar.</p>
<pre><code>$ brew install git
</code></pre>
<p>Com isso você vai usar a última versão estável.</p>
<h3 id="5-crie-aliases-para-agilizar-seu-trabalho">5. Crie aliases para agilizar seu trabalho</h3>
<p>Atalhos para mais produtividade, o Git oferece aliases para que possamos economizar alguns caracteres, veja como usar</p>
<pre><code>$ git config --global alias.co checkout
$ git co production
Switched to branch &#39;production&#39;
</code></pre>
<p>outro exemplo</p>
<pre><code>$ git config --global alias.st status
$ git st
On branch gh-pages
nothing to commit, working tree clean
</code></pre>
<p>Uma outra forma de criar aliases é editar seu gitconfig e setar manualmengte</p>
<pre><code>$ vim ~/.gitconfig
</code></pre>
<p>Adicione uma sessão com essa</p>
<pre><code>[alias]
    co = checkout
    st = status
</code></pre>
<p>Simples e rápido!</p>
<h2 id="junte-seu-time-e-defina-os-padrões-que-vão-usar">Junte seu time e defina os padrões que vão usar</h2>
<p>Agora que seu GIT já está atualizado e configurado vamos definir algumas coisas.</p>
<h3 id="6-sente-com-seu-time-e-formalize-o-padrão-de-versionamento-que-vão-seguir">6. Sente com seu time e formalize o padrão de versionamento que vão seguir</h3>
<p>Combinar antes é sai mais barato do que arrumar depois, converse com seu time e defina:</p>
<ul>
<li>Convenções comuns</li>
<li>Quais serão e como usar branchs de integração</li>
<li>Quais serão e como usar branchs de features</li>
<li>Quais serão e como usar demais branchs</li>
<li>Padrão de nome de branchs para integração<ul>
<li>feature-xyz, hotfix-xyz, stage, test, prod</li>
</ul>
</li>
<li>Padrão esperado para commit, forma, mensagens </li>
<li>Templates e forma de se fazer merge</li>
<li>Regras gerais do que se deve ou se deve não fazer</li>
</ul>
<p>Eu sugiro que crie um repo git e coloque tudo isso em formato MD, nada melhor do que versionar suas regras :)</p>
<h2 id="boas-práticas-com-branchs">Boas práticas com branchs</h2>
<h3 id="7-use-e-abuse-de-branchs">7. Use e abuse de branchs</h3>
<p>O recurso de branch é fantástico, você pode criar a partir de qualquer uma.</p>
<p>Dicas principais:</p>
<ul>
<li>Evite gravar diretamente na main.</li>
<li>Sempre trabalhe em uma branch separada</li>
<li>Integre sua branch quando finalizar seu trabalho</li>
<li>Apague sua branch depois que tiver terminado</li>
</ul>
<p>Exemplo</p>
<pre><code>$ git branch -u main correcao_criacao_vpc
$ git checkout correcao_criacao_vpc
</code></pre>
<p>Quando terminar seu ticket, apague a branch</p>
<pre><code>$ git branch -D correcao_criacao_vpc
</code></pre>
<h3 id="8-use-branchs-de-integração">8. Use branchs de integração</h3>
<p>Quando estamos trabalhando com integração contínua o uso de <strong>branchs</strong> de <strong>integração</strong> é fundamental, precisamos integrar nosso código com o código de nossos colegas e rodar os testes na pipeline.</p>
<p>Geralmente temos uma branch de integração para <strong>desenvolvimento</strong> e depois vamos promovendo esse código para outras branchs que vão nos ajudar a <strong>fechar a release e publicar</strong>, tudo depende do <strong>git-flow</strong> que seu time acordou e está seguindo.</p>
<h3 id="9-não-escreva-direto-na-branch-main">9. Não escreva direto na branch MAIN</h3>
<p>Evitamos escrever direto na branch <strong>main</strong> pois geralmente é a última versão estável devidamente testada e validada por todos, é de fato a fonte da verdade, portanto, para colocar código lá devemos sempre passar por diversos testes em sua pipeline e revisões de seus colegas.</p>
<h3 id="10-mantenha-sua-feature-branch-atualizada">10. Mantenha sua feature-branch atualizada</h3>
<p>Faça rebases regulares para garantir isso!</p>
<p>Exemplo de atualização da branch main localmente e depois rebase</p>
<pre><code>$ git checkout main
$ git pull
$ git checkout feature-xyz  
$ git rebase main  
</code></pre>
<p>Exemplo de merge do código com a main</p>
<pre><code>$ git checkout main
$ git pull
$ git merge feature-xyz
</code></pre>
<p>Hoje em dia eu quase não faço merge no braço, geralmente uso MR ou PR, depende da ferramenta que estamos usando. </p>
<h3 id="11-de-vez-em-quando-recrie-suas-branchs-de-integração">11. De vez em quando recrie suas branchs de integração</h3>
<p>Isso é legal de fazer para dar uma limpada na coisa toda e começar novamente.</p>
<pre><code>$ git checkout main
$ git branch -D devel
$ git branch -u main devel
</code></pre>
<h3 id="12-limpe-periodicamente-branchs-de-feature">12. Limpe periodicamente branchs de feature</h3>
<p>O ideal é sempre apagar suas branchs de feature ou de teste após finalizar um ticket.</p>
<p>Apesar de ser o ideal, nem sempre lembramos, então de vez em quando é bom olhar e apagar branchs que não estão sendo usadas.</p>
<p>Pode-se até definir um tempo de vida para branchs que não são fixas, e definindo isso podemos até criar uma automação para limpar o repo.</p>
<h2 id="boas-práticas-com-commit">Boas práticas com commit</h2>
<h3 id="13-corrija-as-mensagens-do-seu-commit-se-errar">13. Corrija as mensagens do seu commit se errar</h3>
<p>Caso perceba algum typo na sua mensagem de commit, use o amend para corrigir</p>
<pre><code> $ git commit -v --amend
</code></pre>
<h3 id="14-faça-commits-pontuais-e-objetivos">14. Faça commits pontuais e objetivos</h3>
<p>Evite fazer um commit com dezenas de arquivos, em especial se esses arquivos trazem mais de uma mudança ou correção. Devemos evitar isso pois fica difícil rastrear, entender e revisar o que foi feito no commit.</p>
<p>Prefira fazer commits pequenos e pontuais de algo que está terminado, algo que funciona e que não traga muitas alterações de uma vez só.</p>
<h3 id="15-faça-commits-atômicos-quando-possível">15. Faça commits atômicos quando possível</h3>
<p>Já sabemos que commitar poucas alterações é o melhor caminho, mas dá para ser ainda menor.</p>
<p>Os commits atômicos são aqueles que gravam apenas uma única mudança – ainda que envolva vários arquivos – em um único commit.</p>
<p>É claro que nem sempre dá para fazer, mas é uma prática excelente se conseguir fazer.</p>
<p>A ideia do commit atômico é gravar a menor e mais importante melhoria que voce fez no código, sendo grande suficiente para adicionar algum valor, contudo, pequena o suficiente para ser gerenciada com  flexibilidade.</p>
<p>Se quiser trabalhar dessa forma tenha em mente duas coisas:</p>
<ul>
<li>Trabalhe em uma coisa por vez</li>
<li>Faça alterações pequenas e pontuais</li>
</ul>
<h3 id="16-faça-commits-regulares-e-frequentes">16. Faça commits regulares e frequentes</h3>
<p>Não espere demais!</p>
<p>Algumas pessoas esperam demais até gravar alguma alteração, às vezes ficam ali melhorando algo que já está funcionando, buscando algum tipo de perfeição antes de gravar.</p>
<p>Deixa eu te dizer uma coisa, o git funciona melhor e te ajuda mais quando você grava com frequência ao invés de esperar muitoooo tempo para gravar sua mudança. </p>
<p>Ao gravar com frequência você vai rastrear inclusive como você foi melhorando aquele código ao longo do seu processo e histórico de desenvolvimento.</p>
<p>E lembre-se, o GIT só cuida do seu código depois que você grava, se você fechar o editor por acidente ou se o editor travar, seu código já era, contudo, se estiver commitando com frequência você evita isso.</p>
<h3 id="17-quebre-seu-commit-em-commits-menores">17. Quebre seu commit em commits menores</h3>
<p>As vezes a gente vai trabalhando e se empolga demais, e com isso acaba fazendo mais de uma alteração em um mesmo arquivo, e neste caso,  tais alteraçoes que poderiam ser commitadas de forma separada. Se for esse o caso, o commando abaixo te permite escolher quais mudanças você deseja commitar em um determinado arquivo.</p>
<pre><code>$ git add -p &lt;nome_do_arquivo&gt;
</code></pre>
<p>Assim vamos conseguir commitar pequenas porções do arquivo por vez.</p>
<h3 id="18-não-faça-commit-de-algo-que-você-não-finalizou">18. Não faça commit de algo que você não finalizou</h3>
<p><strong>Nunca</strong>, eu repito, <strong>nunca</strong> grave algo que não está funcionando ou que não está completo.</p>
<h3 id="19-teste-seu-código-antes-de-gravar">19. Teste seu código antes de gravar</h3>
<p>Essa é uma das coisas mais básicas que vou falar hoje, mas tem que falar e tem que fazer.</p>
<p>Caso não saiba, gravar código quebrado é algo bastante incômodo, poderá irritar seus colegas, podendo em alguns casos chegar a ser considerado uma falta de respeito e falta de profissionalismo.</p>
<p>Verifique a sintaxe do seu código, rode um linter e execute o código para ver se o que fez está funcionando, seja uma feature, seja um bugfix, seja um hotfix, afinal, se o código estiver funcionando e se sua solução resolver o ticket, isso será o melhor dos mundos.</p>
<p>O git inclusive oferece um sistema de HOOKS que permite por exemplo, executar comandos de checagem antes de de gravar seu código, nesse caso estou falando do hook “pre-commit”, veja o link abaixo e leia sobre esse e outros hooks, é um recurso muito útil, acredite.</p>
<ul>
<li><a href="https://git-scm.com/docs/githooks">https://git-scm.com/docs/githooks</a></li>
</ul>
<h3 id="20-escreva-mensagens-de-commit-claras">20. Escreva mensagens de commit claras</h3>
<p>As mensagens precisam fazer sentido e ser úteis para todos do time.</p>
<h4 id="201-commitando-em-uma-linha">20.1 Commitando em uma linha</h4>
<p>A mensagem tem que fazer sentido, ser fácil de ler e ser suficiente para entender o que foi feito.</p>
<h5 id="exemplos">Exemplos</h5>
<p>Podemos usar convenções para mostrar que fizemos uma <strong>correção</strong></p>
<pre><code>fix: corrige bug quando modulo vai crair a 2o VPC na AWS
</code></pre>
<p>ou uma <strong>refatoração</strong></p>
<pre><code>refact: refatora código que configura IAM para EKS na AWS
</code></pre>
<p>ou uma <strong>documentação</strong></p>
<pre><code>doc: adiciona docs para uso do modulo IAM/EKS
</code></pre>
<p>ou que inserimos <strong>testes</strong></p>
<pre><code>test: adiciona testes unitários no módulo
    
</code></pre>
<p>ou que criamos uma nova <strong>feature</strong></p>
<pre><code>feat: adiciona recurso para lidar com ALB no EC2/AWS
</code></pre>
<h5 id="entendendo-a-estrutura">Entendendo a estrutura</h5>
<p>É simples</p>
<pre><code>feat: adiciona fature para recursos ALB no EC2/AWS #220412
^--^  ^-----------------------------------------^
|     |
|     +-&gt; Sumário da sua mudança
|
+-------&gt; Tipo: docs, feat, fix, refact, ou test.
</code></pre>
<p>Se você estiver usando um sistema de tickets junto, adicione o número do ticket na mensagem, sistemas como GitLab e GitHub já farão a associação para você entre a issue e o commit.</p>
<p>Evite colocar ponto final na mensagem, afinal é um título.</p>
<p>Vale lembrar que você deve evitar escrever mais de 50 caracteres ou vai quebrar a saída do “git log”.</p>
<h5 id="de-que-modo-escrever-a-mensagem">De que modo escrever a mensagem?</h5>
<p>Em alguns blogs vocês verão pessoas que defendam usar verbos no imperativo ou presente do indicativo, e faz sentido. Em ambos os casos a ideia é que o commit responda essa pergunta:</p>
<pre><code>  &quot;Em caso de aplicar esse commit ele...&quot;
</code></pre>
<p>Resposta</p>
<pre><code>...altera código X
...corrige módulo Y
...refatora manifesto Z
...cria feature W para módulo X
</code></pre>
<p>Eu já gosto de usar particípio do passado, pois foi algo que já foi realizado e nem precisa fazer a perguntinha para ver como tem que escrever, neste caso você pode afirmar ao invés de perguntar, dessa forma:</p>
<pre><code>&quot;Nesse commit foi...&quot;
</code></pre>
<p>Resposta</p>
<pre><code>...alterado código X
...corrigido módulo Y
...refatorado manifesto Z
...criada a feature W para módulo X
</code></pre>
<p>Enfim, existem longas threads sobre isso na internet, quase uma guerra santa, contudo, IMHO isso vai depender de cada um, ou da forma como cada time decidiu trabalhar.</p>
<p>No final o importante é você versionar seu código e conseguir entender o que fez ali lendo a mensagem de commit :)</p>
<h4 id="202-usando-o-editor-para-algo-mais-detalhado">20.2 Usando o editor para algo mais detalhado</h4>
<p>As vezes precisamos escrever um pouco mais, indo além do “one line commit”, especialmente se foi uma correção complexa, se tem alguma pegadinha, ou se for preciso explicar porque você fez aquilo daquela forma. No caso do trabalho e o dia-a-dia dos Cloud Engineers nem sempre é necessário, mas se for, veja como fazer.</p>
<p>Nesse caso, como é uma mensagem longa, não podemos fazer “one line commit”, temos que ir para o editor.</p>
<pre><code>$ git commit
</code></pre>
<p>E escrever a mensagem</p>
<pre><code>Assunto da mensagem com no máximo 50 caracteres, sem ponto final

Descrição em múltiplas linhas
sobre seu commit. Use até 72 caracteres

Outros parágrafos podem vir após inserir 
uma linha em branco
Aqui nao tem mais limite de caracteres

Podemos usar bullets também, ajuda a organizar a informação

- Enumerando
- Alterações
- Realizadas
- Por
- Este
- Commit

Se existe um ticket coloque 
o número dele na mensagem e os tickets relacionados

Esse commit resolve o problema do ticket #2222
E está relacionado com o ticket #3333 e #4444
</code></pre>
<p>É bem simples!</p>
<h3 id="21-não-reescreva-o-histórico-da-branch-principal">21. Não reescreva o histórico da branch principal</h3>
<p>Se você já gravou o código na branch principal, e o código alterado já está disponível para outras pessoas verem, recomenda-se não alterar esse histórico.</p>
<p>Fazer rebase na MAIN ou qualquer que seja o nome da sua branch upstream, ou mesmo em uma branch de integração pode causar problemas para seus colegas e eles podem ter que lidar com conflitos ou ter que fazer stash e baixar toda a branch novamente. Fora que normalmente alterações nessas branchs geralmente acionam gatilhos em ferramentas de CICD, o que pode gerar um deploy com regressão.</p>
<p>Dito isso, muito cuidado com suas branchs, em especial a upstream e as branchs de integração.</p>
<p>Na sua branch de feature você faz o que quiser, use o rebase sem problema algum, mas só nela ok?</p>
<h2 id="boas-práticas-com-merge">Boas práticas com merge</h2>
<h3 id="22-faça-squash-antes-de-fazer-um-merge">22. Faça squash antes de fazer um merge</h3>
<p>Antes de fazer um merge verifique seu histórico de commit, veja se é possível melhorar o histórico, reduzir e juntar algumas coisas, as vezes 20 commits podem ser agrupados em 10, fica mais limpo, organizado e facilitará a revisão por seus pares.</p>
<pre><code>$ git rebase -i HEAD~20  # apresenta os últimos 20 commits para fazer o squash
</code></pre>
<p>Faça o squash na sua branch de trabalho antes de mandar o PR/MR e altere apenas os seus commits ok?</p>
<h3 id="23-use-e-abuse-de-mrs-e-prs-no-github-e-gitlab">23. Use e abuse de MRs e PRs no GitHub e GitLab</h3>
<p>A vantagem de usar PR ou MR seja no GitLab ou GitHub é que você tem facilidades para fazer squash, resolver conflitos, enxergar o que mudou (diff), solicitar revisão de pares, receber comentários e então finalmente fazer o merge. São excelentes recursos e devemos usá-los pois facilitam nossa vida.</p>
<h2 id="outras-coisas-interessantes">Outras coisas interessantes</h2>
<h3 id="24-use-nomes-consistentes-para-seus-remotes">24. Use nomes consistentes para seus remotes</h3>
<p>Origin é um nome padrão, mas não é obrigatório tá?</p>
<pre><code>$ git push origin main
</code></pre>
<p>Podemos mudar esse nome para dar mais contexto e ficar mais claro de qual remote estamos falando</p>
<pre><code>$ git push gitlab main
$ git push github main
$ git push bitbucket main
$ git push clienteX main
</code></pre>
<p>Colocar um contexto no nome do remote ajuda bastante, especialmente se tem vários remotes.</p>
<h3 id="25-prefira-autenticação-ssh-ao-invés-de-usersenha">25. Prefira autenticação SSH ao invés de user/senha</h3>
<p>Autenticação através de chaves é mais segura, tanto que algumas ferramentas como GitHub desabilitam push em outros métodos.</p>
<h4 id="criando-uma-chave-ssh-segura-ed2559">Criando uma chave ssh segura (ed2559)</h4>
<p>Como criar um chave segura?</p>
<pre><code>$ ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/nome_da_sua_chave -C “nome@domain.ext”
</code></pre>
<p>Quer saber por que usar o  ed25519?</p>
<p>Basicamente pois é um algoritmo mais moderno que usa curvas elípiticas, mais performático comparado com outras alternativas.</p>
<p>Se quiser saber mais mergulhe nesse post!</p>
<ul>
<li><a href="https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54">https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54</a></li>
</ul>
<h4 id="definindo-o-uso-de-chaves-ssh-para-repos-específicos">Definindo o uso de chaves ssh para repos específicos</h4>
<p>No meu caso eu trabalho com várias chaves ssh, uma para projetos pessoais, uma para projetos na empresa que trabalho e sempre crio chaves para projetos ou freelas que eu estou fazendo.</p>
<p>É sempre bom evitar usar a mesma chave para tudo.</p>
<p>Mas como organizar isso?</p>
<p>Simples edite o arquivo ~/.ssh/config e configure a chave para cada server </p>
<pre><code>Host nativeltrail_gitlab
  Hostname gitlab.nativetrail.io
  User git
  IdentityFile ~/.ssh/id_ed2559_gitlab_nativetrail_key

Host client_x_gitlab
  Hostname gitlab.cliente-x.com
  User git
  IdentityFile ~/.ssh/id_ed2559_gitlab_clientex_key
  
Host gitlab
  Hostname gitlab.com
  User git
  IdentityFile ~/.ssh/id_ed2559_gitlab_key 

Host github
  Hostname github.com
  User git
  IdentityFile ~/.ssh/id_ed2559_github_key  
</code></pre>
<p>Pronto, diferentes chaves para diferentes servidores e serviços.</p>
<h3 id="26-use-e-abuse-do-gitignore">26. Use e abuse do .Gitignore</h3>
<p>O Gitignore é um arquivo essencial em nosso repositório, é através dele que dizemos para o GIT ignorar alguns arquivos e não versioná-los.</p>
<p>O Github traz uma bela coleção de templates para isso, veja no link abaixo:</p>
<ul>
<li><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></li>
</ul>
<h4 id="usando-o-gitignore-local">usando o gitignore local</h4>
<p>neste caso crie na raiz do diretorio um arquivo com o nome .gitignore e insira o que deseja ignorar.</p>
<pre><code>_site
_temp
_build
*.zip
*.tar.gz
</code></pre>
<p>e pronto, seu git vai ignorar esses padroes, saiba mais na documentação:</p>
<ul>
<li><a href="https://git-scm.com/docs/gitignore">https://git-scm.com/docs/gitignore</a></li>
</ul>
<h4 id="usando-o-gitignore-global">usando o gitignore global</h4>
<p>Esse arquivo é global e todos os projetos vão ler ele, é bem útil para coisas comuns e para projetos que ainda não tem um .gitignore construído</p>
<p>Criando o arquivo</p>
<pre><code>$ touch ~/caminho/para/seu/global/.gitignore
</code></pre>
<p>Ativando via CLI</p>
<pre><code>$ git config --global core.excludesFile ~/caminho/para/seu/global/.gitignore
</code></pre>
<p>Caso prefira edite seu .gitconfig diretamente e insira a configuração</p>
<pre><code>[core]
  excludesFile = ~/caminho/para/seu/global/.gitignore
</code></pre>
<p>No mac eu uso esse conteúdo</p>
<pre><code># General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon

# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# Files that might appear on external disks
.Spotlight-V100
.Trashes

# Vscode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/*.code-snippets

# Local History for Visual Studio Code
.history/

# Built Visual Studio Code Extensions
*.vsix
</code></pre>
<h3 id="27-use-tags-para-criar-referências-no-seu-histórico">27. Use tags para criar referências no seu histórico</h3>
<p>Tags que identificam milestones</p>
<pre><code>$ git tag milestone-id -m
$ git push --tags
</code></pre>
<p>Tags que identificam um estado</p>
<pre><code>$ git tag stable -m
$ git push --tags
</code></pre>
<p>Tags que identificam versões</p>
<pre><code>$ git tag v1.2.3 -m
$ git push --tags
</code></pre>
<p>Existem várias formas de usar tags, seu uso facilita a identificação de um momento específico em seu histórico de desenvolvimento, tal como o fechamento de uma release, a conclusão de um milestones, a identifição e uma versão, o que possibilita que façamos clone do código naquele momento exato.</p>
<h3 id="28-se-possível-use-versionamento-semântico">28. Se possível use versionamento semântico</h3>
<p>Caso não conheça acessa o site <a href="https://semver.org">https://semver.org</a></p>
<p>O versionamento semântico consiste basicamente no uso de três numeros que podem ser incrementados, como o exemplo abaixo:</p>
<pre><code>2.3.5
</code></pre>
<h5 id="major">MAJOR</h5>
<p>O primeiro número é chamado de <strong>major</strong>, ele deve ser incrementando quando alguma mudança causa uma quebra de compatilidade de API</p>
<h5 id="minor">MINOR</h5>
<p>O segundo número é chamado de <strong>minor</strong>, ele deve ser incrementado quando uma nova funcionalidade é adicionada, sem quebra de compatibilidade</p>
<h5 id="patch">PATCH</h5>
<p>O terceiro número é chamado de <strong>patch,</strong> ele deve ser incrementado quando fazemos algum tipo de correção na versão minor</p>
<h5 id="buildrelease">BUILD/RELEASE</h5>
<p>Ao ler o semver.org você verá outras possibilidades de versionar, usando build number e release name, veja alguns exemplos:</p>
<pre><code>1.0.0-alpha
1.0.0-beta
1.0.0-rc1
1.0.0-rc2
1.0.0+20130313144700
1.0.0-0.3.7
</code></pre>
<p>O versionamento semântico é bem flexível e fácil de usar, você vai ver.</p>
<h4 id="posso-automatizar-o-incremento-de-versão">Posso automatizar o incremento de versão?</h4>
<p>Como as regras são claras fica fácil entender como incrementar a versões manualmente e podemos até mesmo automatizar isso em nossa pipeline.</p>
<h4 id="posso-criar-o-meu-próprio-método">Posso criar o meu próprio método?</h4>
<p>Claro, cada time pode definir seu jeito de versionar, mas lembre-se criar um repo onde você explica isso para todo mundo, em formato MD. :)</p>
<h3 id="29-cuidado-com-push-usando-force">29. Cuidado com Push usando FORCE</h3>
<p>Quando você manda um</p>
<pre><code>$ git push origin main --force
</code></pre>
<p>Você está sobrescrevendo tudo que tem no ORIGIN na branch MAIN.</p>
<p>Todo o cuidado é pouco, se for fazer avise a turma, peça permissão e faça um backup antes.</p>
<h4 id="quais-problemas-isso-pode-gerar">Quais problemas isso pode gerar?</h4>
<p>Se alguém fez um push e você não atualizou sua branch local, os commits do coleginha serão perdidos.</p>
<p>Se alguém fez um clone e você mandou um force removendo várias coisas, no próximo pull o coleginha vai lidar com conflitos ou coisas piores, talvez tenha até que apagar o repo e baixar novamente.</p>
<p>Isso pode gerar algumas situações chatas com seu time, tome cuidado, use com cuidado.</p>
<h3 id="30-aprenda-mais-sobre-o-git-e-pratique">30. Aprenda mais sobre o GIT e pratique</h3>
<p>Aprender, entender e usar boas práticas vem com a experiência do dia a dia, quanto mais ler para conhecer seus recursos, quanto mais usar, mais precisará aprender, é assim que funciona.</p>
<p>Então vai lá e estuda!</p>
<ul>
<li><a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></li>
</ul>
<p>Sucesso!</p>
<h2 id="refs">Refs</h2>
<ul>
<li><a href="https://deepsource.io/blog/git-best-practices/">https://deepsource.io/blog/git-best-practices/</a></li>
<li><a href="https://opensource.com/article/20/7/git-best-practices">https://opensource.com/article/20/7/git-best-practices</a></li>
<li><a href="https://cbea.ms/git-commit">https://cbea.ms/git-commit</a></li>
<li><a href="https://github.com/git-tips/tips">https://github.com/git-tips/tips</a></li>
<li><a href="https://codeburst.io/git-tips-and-tricks-to-improve-your-git-workflow-3f8652fa4a62">https://codeburst.io/git-tips-and-tricks-to-improve-your-git-workflow-3f8652fa4a62</a></li>
</ul>
<p>[s]<br>
Guto</p>
<p>Se gostou manda um alo no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a>.</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Entendendo VCS centralizado e distribuído</title>
        <author>
            <name>Guto Carvalho</name>
        </author>
        <link href="https://gutocarvalho.net/entendendo-vcs-centralizado-e-distribuido/"/>
        <id>https://gutocarvalho.net/entendendo-vcs-centralizado-e-distribuido/</id>
            <category term="MindNotes"/>

        <updated>2022-02-16T08:45:53-03:00</updated>
            <summary>
                <![CDATA[
                    Essa é outra daquelas perguntinhas marotas de entrevistas, bora entender isso direitinho&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Essa é outra daquelas perguntinhas marotas de entrevistas, bora entender isso direitinho para responder com segurança!</p>
<h2 id="vcs">VCS?</h2>
<p><strong>VCS</strong> significa <strong>version control system</strong>, ou sistema de controle de versões.</p>
<p>O <strong>GIT</strong> é o mais famoso hoje, o qual faz parte do grupo dos <strong>distribuídos</strong>.</p>
<p>Mas qual a diferença entre sistemas <strong>centralizados</strong> e <strong>distribuídos</strong>?</p>
<h2 id="vsc-centralizado">VSC Centralizado</h2>
<p>O sistema centralizado, como o nome diz tem um servidor ou serviço central e funciona na arquitetura <strong>cliente/servidor</strong>. Este servidor tem todas as versões do código.</p>
<p>Para trabalhar em um projeto você precisa instalar o cliente e fazer o download de todo o código e <strong>sempre vai depender do servidor para gravar suas modificações</strong>, se ele não estiver no ar você não consegue fazer seus commits, e isso te impede de trabalhar.</p>
<p>A dependência do serviço no ar para  trabalhar por si só já é algo que pode incomodar, além disso, temos um problema maior ainda, uma vez que todo o código está no servidor, perdeu o servidor, perdeu o código e aí ninguém trabalha mesmo.</p>
<p>Em resumo, se o servidor estiver fora, ninguém faz nada.</p>
<p>Os VCS centralizados podem até ser mais simples de instalar, manter e usar, mas o risco de um ponto único de falha é muito grande para assumir hoje em dia.</p>
<p>Exemplos de sistemas centralizados:</p>
<ul>
<li>SVN</li>
<li>CVS</li>
<li>Perforce</li>
</ul>
<h2 id="vcs-distribuído">VCS Distribuído</h2>
<p>No VCS distribuído <strong>todo mundo tem a cópia do software em sua máquina</strong>, pode trabalhar <strong>localmente</strong> e depois enviar e <strong>integrar</strong> seu código em um repositório intermediário usado para isso, no caso do GIT chamamos esse locais de <strong>remotes</strong>.</p>
<p>Como todo mundo tem o código, <strong>temos múltiplos backups</strong> e caso o repositório de alguém se corrompa, podemos facilmente pegar a cópia de outro desenvolvedor e seguir trabalhando.</p>
<p>Como temos uma cópia local, <strong>podemos trabalhar offline</strong> e depois enviar e integrar o código com dos nossos colegas, e saiba que trabalhar local é bem mais rápido.</p>
<p>A criação de <strong>branchs</strong> é rápida e objetiva pq é tudo local e não precisa contatar um servidor central <strong>toda a vez que for criar uma branch</strong>.</p>
<p>A única coisa que precisa ficar claro é a curva de aprendizado <strong>pode</strong> ser maior do que sistemas mais simples e centralizados, contudo, o poder, a flexibilidade, a segurança e a velocidade de trabalhar superam esse detalhe.</p>
<p>Exemplos de sistemas centralizados:</p>
<ul>
<li><strong>GIT</strong></li>
<li><strong>Mercurial</strong></li>
<li>Bazaar</li>
</ul>
<h2 id="amarrando-as-pontas">Amarrando as pontas</h2>
<p>Hoje o <strong>GIT</strong> se tornou padrão do mercado, todo mundo usa, conhece e sabe trabalhar, contudo, não é incomum encontrar empresas usando Mercurial o segundo mais popular entre os distribuídos.</p>
<p>Espero que tenha te ajudado a entender a diferença :)</p>
<p>[s]<br>
Guto</p>
<p>–</p>
<p>Este post é do tipo #MindNotes, entenda <a href="https://gutocarvalho.net/o-que-sao-mindnotes/">aqui</a>.</p>
<p>Se gostou manda um alo no twitter <a href="https://twitter.com/gutocarvalho">@gutocarvalho</a>.</p>

            ]]>
        </content>
    </entry>
</feed>
